# Story 8.4: Flex Run Output & Snapshot Persistence

## Status
Draft

## Story
**As a** systems auditor,  
**I want** flex runs to persist final outputs and plan snapshots,  
**so that** we can reconstruct decisions, support resume flows, and analyze orchestration results after the stream completes.

## Acceptance Criteria
1. Database schema includes `flex_run_outputs` table storing validated final payloads, client schema hashes, and completion metadata.
2. `flex_plan_snapshot` (or equivalent) persists serialized plan state at pause points (HITL, errors) to support reliable rehydration.
3. Execution engine writes final output and latest snapshot transactionally upon run completion or pause.
4. Repository/service layer exposes read functions for run outputs and plan snapshots without breaking legacy code.

## Tasks / Subtasks
- [ ] Add Drizzle migrations for `flex_run_outputs` and `flex_plan_snapshot` tables with necessary indexes (AC 1, AC 2).
- [ ] Extend execution engine to persist final output JSON, schema hash, and completion timestamp (AC 3).
- [ ] Persist plan snapshot whenever runs pause for HITL or encounter retriable errors (AC 2, AC 3).
- [ ] Expose repository functions in flex server for retrieving output/snapshot data (AC 4).
- [ ] Update docs (`docs/architecture/flex-agents-server.md`) to mention new tables and persistence flow (AC 1-3).
- [ ] Add unit/integration tests ensuring data is written/read correctly (AC 3, AC 4).

## Story Context

**Existing System Integration:**
- Integrates with: Flex server persistence layer, shared DB package, HITL resume logic.
- Technology: Drizzle ORM, Postgres JSONB columns, Nitro services.
- Follows pattern: Legacy orchestrator stores plan artifacts and outputs for auditing.
- Touch points: `@awesomeposter/db`, `packages/flex-agents-server/src/services`.

## Acceptance Criteria (Detailed)

### Functional Requirements
1. `flex_run_outputs` captures run ID, JSON payload, schema hash, completion status, created/updated timestamps.
2. `flex_plan_snapshot` stores run ID, serialized plan graph (JSON), pending node IDs, and updated timestamp.
3. Resume logic loads latest snapshot and remaining node context during run rehydration.
4. Deleting or truncating flex tables does not impact legacy orchestrator tables (isolated schema).

### Integration Requirements
5. Drizzle migrations are additive and versioned; both agents servers share the same migration chain.
6. Repository methods are exported for use by future API endpoints (`GET /api/v1/flex/runs/:id`).

### Quality Requirements
7. Integration tests cover pause/resume scenarios to ensure snapshots reload correctly.
8. Final output persistence is idempotent (repeated completion writes overwrite/patch same row).
9. Documentation updated with storage expectations and retention considerations.

## Technical Notes
- **Integration Approach:** Use JSONB for payloads; store schema hash as SHA256 string for quick verification.
- **Existing Pattern Reference:** Legacy orchestrator run output storage (if any) or general Drizzle table templates under `packages/db`.
- **Key Constraints:** Ensure plan snapshots are compact; consider compression if payloads grow large.

## Definition of Done
- [ ] Functional requirements met
- [ ] Integration requirements verified
- [ ] Existing functionality regression tested (legacy tables unaffected)
- [ ] Code follows existing patterns and standards
- [ ] Tests pass (unit/integration)
- [ ] Documentation updated (DB schema + architecture)

## Risk and Compatibility Check
- **Primary Risk:** Large snapshots increasing storage costs or slowing resume.
- **Mitigation:** Serialize minimal plan state and consider TTL cleanup in future ticket.
- **Rollback:** Revert migrations and persistence code; flex runs continue streaming without stored outputs.

**Compatibility Verification**
- [x] No breaking changes to existing APIs
- [x] Database changes (if any) are additive only
- [x] UI changes follow existing design patterns
- [x] Performance impact is negligible

## Validation Checklist
- [ ] Story can be completed in one development session
- [x] Integration approach is straightforward
- [x] Follows existing patterns exactly
- [x] No design or architecture work required
- [x] Story requirements are unambiguous
- [x] Integration points are clearly specified
- [x] Success criteria are testable
- [x] Rollback approach is simple

## Success Criteria
1. Flex runs persist their final outputs and snapshots without affecting legacy data.
2. Resume flow loads snapshots to continue execution seamlessly.
3. Operators can query stored outputs for auditing and analysis.

## Important Notes
- Coordinate retention strategy with ops; large payloads may require archiving in future sprints.
