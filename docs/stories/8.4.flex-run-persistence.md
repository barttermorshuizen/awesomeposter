# Story 8.4: Flex Run Output & Snapshot Persistence

## Status
Draft

## Story
**As a** systems auditor,  
**I want** flex runs to persist final outputs and plan snapshots,  
**so that** we can reconstruct decisions, support resume flows, and analyze orchestration results after the stream completes.

## Acceptance Criteria
1. Database schema includes `flex_run_outputs` storing validated final payloads, caller schema hashes, plan version ID, and facet provenance metadata for the delivered output. (`docs/architecture/flex-agents-server.md:303`)
2. `flex_plan_snapshot` persists serialized plan versions capturing node facet arrays, compiled `inputSchema`/`outputSchema`, provenance, and pending node state at pause/replan checkpoints. (`docs/architecture/flex-agents-server.md:138`)
3. Execution engine writes final outputs and snapshots transactionally whenever runs complete, pause for HITL, or commit a replanned graph, ensuring the latest plan version is recorded. (`docs/architecture/flex-agents-server.md:205`)
4. Repository/service layer exposes read functions that return outputs, plan versions, and facet provenance for resume/debug APIs without impacting legacy code paths. (`docs/architecture/flex-agents-server.md:178`)
5. Documentation reflects the facet-aware persistence flow and plan version storage responsibilities. (`docs/architecture/flex-agents-server.md:449`)

## Tasks / Subtasks
- [ ] Add Drizzle migrations for `flex_run_outputs` / `flex_plan_snapshot` including plan version ID and facet provenance columns (AC 1, AC 2).
- [ ] Extend execution engine persistence hooks to write outputs with schema hash, plan version ID, and facet provenance metadata (AC 1, AC 3).
- [ ] Capture plan snapshots (pause, error, replan commit) with node facet arrays, compiled schemas, and pending node IDs (AC 2, AC 3).
- [ ] Expose repository functions returning structured output + plan version + provenance for resume/debug endpoints (AC 4).
- [ ] Update docs (`docs/architecture/flex-agents-server.md`) to reflect facet-aware persistence and plan version storage (AC 5).
- [ ] Add unit/integration tests covering output persistence, snapshot rehydration with facet metadata, and repository reads (AC 3, AC 4).

## Story Context

**Existing System Integration:**
- Integrates with: Facet catalog/contract compiler (Story 8.12), flex server persistence layer, HITL resume logic, planner hybrid loop (Story 8.14).
- Technology: Drizzle ORM, Postgres JSONB columns, Nitro services.
- Follows pattern: Legacy orchestrator stores plan artifacts and outputs for auditing.
- Touch points: `@awesomeposter/db`, `packages/flex-agents-server/src/services`, `FacetContractCompiler` outputs consumed by planner/execution.

## Acceptance Criteria (Detailed)

### Functional Requirements
1. `flex_run_outputs` captures run ID, JSON payload, schema hash, plan version ID, facet provenance map, completion status, timestamps.
2. `flex_plan_snapshot` stores run ID, plan version ID, serialized nodes (with facet arrays + compiled schemas), pending node IDs, updated timestamp.
3. Resume/replan logic loads the latest snapshot and remaining node context, restoring facet metadata and compiled schemas for deterministic execution.
4. Deleting or truncating flex tables does not impact legacy orchestrator tables (isolated schema).

### Integration Requirements
5. Drizzle migrations are additive and versioned; both agents servers share the same migration chain.
6. Repository methods are exported for use by future API endpoints (`GET /api/v1/flex/runs/:id`).

### Quality Requirements
7. Integration tests cover pause/resume scenarios to ensure snapshots reload correctly.
8. Final output persistence is idempotent (repeated completion writes overwrite/patch same row).
9. Documentation updated with storage expectations and retention considerations.

## Technical Notes
- **Integration Approach:** Use JSONB for payloads and facet provenance; store schema hash and plan version IDs for quick verification.
- **Existing Pattern Reference:** Legacy orchestrator run output storage (if any) or general Drizzle table templates under `packages/db`.
- **Key Constraints:** Ensure snapshots include facet arrays and compiled schemas without exploding size; consider compression or selective fields if payloads grow large.

## Definition of Done
- [ ] Functional requirements met
- [ ] Integration requirements verified
- [ ] Existing functionality regression tested (legacy tables unaffected)
- [ ] Code follows existing patterns and standards
- [ ] Tests pass (unit/integration)
- [ ] Documentation updated (DB schema + architecture)

## Risk and Compatibility Check
- **Primary Risk:** Large snapshots increasing storage costs or slowing resume.
- **Mitigation:** Serialize minimal plan state and consider TTL cleanup in future ticket.
- **Rollback:** Revert migrations and persistence code; flex runs continue streaming without stored outputs.

**Compatibility Verification**
- [x] No breaking changes to existing APIs
- [x] Database changes (if any) are additive only
- [x] UI changes follow existing design patterns
- [x] Performance impact is negligible

## Validation Checklist
- [ ] Story can be completed in one development session
- [x] Integration approach is straightforward
- [x] Follows existing patterns exactly
- [x] No design or architecture work required
- [x] Story requirements are unambiguous
- [x] Integration points are clearly specified
- [x] Success criteria are testable
- [x] Rollback approach is simple

## Success Criteria
1. Flex runs persist their final outputs and snapshots without affecting legacy data.
2. Resume flow loads snapshots to continue execution seamlessly.
3. Operators can query stored outputs for auditing and analysis.

## Important Notes
- Coordinate retention strategy with ops; large payloads may require archiving in future sprints.
