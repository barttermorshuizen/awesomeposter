# Story 8.22: Flex Policy Conditional Triggers

## Status
Draft

## Story
**As a** flex orchestrator maintainer,  
**I want** policy directives to support conditional `when` predicates,  
**so that** replans or other policy actions only occur when facet data meets explicit thresholds instead of relying on brittle capability-specific logic.

**Dependencies:** Story 8.9 (policy normalization) and Story 8.14 (hybrid planner loop) must be in place so runtime policy evaluation and replans are already wired into the execution flow.

## Acceptance Criteria
1. `TaskEnvelope.policies` directives accept an optional `when` block that can reference facet paths and comparison operators (e.g., QA scores, recommendation counts) with validation errors surfaced when the predicate is malformed. (`docs/architecture/flex-agents-server.md:198`)
2. The policy normalizer parses the `when` block into a reusable predicate structure for all supported directive match types (`capability`, `node`, `stage`, `kind`) without duplicating capability-specific code. (`docs/architecture/flex-agents-server.md:205`)
3. Runtime evaluation loads the current facet snapshots for the triggering node, executes the predicate, and only raises `policy_triggered` when the predicate resolves truthy; evaluation results (matched, skipped, validation failure) are logged for observability. (`docs/architecture/flex-agents-server.md:210`)
4. Predicate-aware triggers are covered by automated tests (happy path, predicate false, malformed predicate) while existing directives without `when` continue to pass unchanged. (`docs/architecture/flex-agents-server.md:220`)
5. Architecture documentation and story references are updated with the conditional syntax, examples (QA retry, HITL escalation), and guidance on facet naming. (`docs/architecture/flex-agents-server.md:352`)

## Tasks / Subtasks
- [ ] Extend policy schema to accept `when` predicates, including validation errors for unsupported operators or missing facet references. (AC 1)
- [ ] Update `PolicyNormalizer` to build predicate ASTs and attach them to directive metadata. (AC 2)
- [ ] Implement a predicate evaluator in the execution path that fetches facet data, runs the predicate, and emits structured logs. (AC 3)
- [ ] Add unit and integration coverage for predicate parsing/evaluation alongside existing directive tests. (AC 4)
- [ ] Refresh architecture docs with conditional trigger syntax, examples, and troubleshooting notes. (AC 5)

## Story Context

**Existing System Integration:**
- Integrates with: `flex-run-coordinator.ts`, `flex-execution-engine.ts`, `PolicyNormalizer`, planner SSE telemetry, facet persistence.
- Technology: TypeScript, policy evaluation utilities, facet snapshots, existing SSE contract.
- Follows pattern: Runtime policy hooks introduced in Story 8.9 and the hybrid planner handshake from Story 8.14.
- Touch points: Policy schema definition, normalizer, execution-time trigger evaluation, telemetry/logging, documentation.

## Acceptance Criteria (Detailed)

### Functional Requirements
1. `when` predicates support comparisons (`<`, `<=`, `=`, `>=`, `>`, `!=`), boolean checks, and collection helpers (`$nonEmpty`, `$includes`) against facet values stored in run context.
2. Multiple predicates can be ANDed/ORed (e.g., score threshold AND recommendations non-empty); nested predicates are supported.
3. Predicate evaluation is deterministic and side-effect free; failures fall back to logging and skip triggering rather than causing hard errors.

### Integration Requirements
4. Predicate evaluation executes after node completion but before planner handshake so replans remain synchronous with execution state.
5. Telemetry events include predicate outcome metadata (matched/ skipped / invalid) to aid debugging in sandbox and operator tooling.
6. Documentation clearly states facet naming conventions and warns against referencing unpersisted facets.

### Quality Requirements
7. Unit tests cover predicate parsing, validation errors, and evaluation edge cases (missing facet, wrong type).
8. Integration tests ensure `policy_triggered` only fires when predicate passes and that legacy directives still work without predicates.
9. Logging output includes run ID, node ID, directive details, predicate expression, and evaluation outcome.

## Technical Notes
- **Integration Approach:** Extend policy schema definitions (Zod) to include predicates, update normalizer to build ASTs, and execute predicates in the existing trigger loop using facet snapshots.
- **Existing Pattern Reference:** Hybrid planner replans (`flex-run-coordinator.ts`) and policy-trigger telemetry to reuse existing logging/SSE plumbing.
- **Key Constraints:** Predicate evaluation must be safe against large facet payloads; enforce depth/size limits to avoid blocking execution.

## Definition of Done
- [ ] Functional requirements met
- [ ] Integration requirements verified
- [ ] Existing functionality regression tested
- [ ] Code follows existing patterns and standards
- [ ] Tests pass (unit and integration)
- [ ] Documentation updated

## Risk and Compatibility Check
- **Primary Risk:** Predicates referencing missing or large facets causing runtime errors or performance hits.
- **Mitigation:** Validate facet paths, cap predicate complexity, fallback to logging when data missing.
- **Rollback:** Disable predicates via feature flag, revert to stage/capability-only triggers.

**Compatibility Verification**
- [x] No breaking changes to existing APIs
- [x] Database changes (if any) are additive only
- [x] UI changes follow existing design patterns
- [x] Performance impact is negligible with predicate guard rails

## Validation Checklist
- [x] Story can be completed in one development session
- [x] Integration approach is straightforward
- [x] Follows existing patterns exactly
- [x] No design or architecture work required
- [x] Story requirements are unambiguous
- [x] Integration points are clearly specified
- [x] Success criteria are testable
- [x] Rollback approach is simple

