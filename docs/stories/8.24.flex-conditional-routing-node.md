# Story 8.24: Flex Conditional Routing Node

## Status
Ready for Dev

## Story
**As a** planner (LLM-based or deterministic hybrid) constructing and executing adaptive plans,  
**I want** to insert Conditional Routing Nodes between capability nodes, representing the logical preconditions that must hold true before a downstream capability node can execute,  
**so that** the system can dynamically route execution based on current context, selectively trigger replanning when preconditions fail, and maintain causal consistency between capabilities without over-expanding the plan graph. 

**Dependencies:** Story 8.22 (policy conditional triggers) must land first so predicates compile to JSON-logic, and Story 8.23 (policy action execution) ensures replan/interrupt nodes already integrate with the execution engine when routing edges target those system nodes.

## Acceptance Criteria
1. `@awesomeposter/shared` exposes `ConditionalRoutingNodeSchema`, `ConditionalRoutingNode`, and supporting `RoutingCondition`/`RoutingEdge` helpers that mirror the informal schema, compile logic DSL predicates to normalized JSON-logic, and reference downstream node IDs instead of runtime action payloads. (`docs/architecture/flex-agents-server.md#54-plangraph`, `docs/architecture/tech-stack.md#1-core-runtime-components`, `docs/architecture/coding-standards.md#1-language--module-conventions`)
2. Flex planner, plan snapshots, and persistence accept a new `FlexPlanNodeKind` for conditional routing nodes (distinct from capability nodes), capturing ordered `routes[]` of `{ if, to }`, optional `elseTo`, and metadata so rehydration preserves the DAG exactly as emitted. (`docs/architecture/flex-agents-server.md#54-plangraph`, `docs/architecture/flex-agents-server.md#7-execution-flow`, `docs/architecture/flex-agents-server.md#9-data-model--persistence`)
3. `FlexExecutionEngine` evaluates preplanned conditional routing nodes before advancing the run: it executes compiled logic predicates against the current `RunContext`, selects the first matching edge’s `to` node ID, and schedules that downstream node without injecting new nodes; fallbacks either advance to the declared `elseTo` capability or raise a planner replan request via the existing replan handshake. (`docs/architecture/flex-agents-server.md#6-component-responsibilities`, `docs/architecture/flex-agents-server.md#7-execution-flow`, `docs/architecture/flex-agents-server.md#8-hitl-and-rehydration-strategy`)
4. Telemetry and persistence capture routing evaluations: SSE frames (e.g., `policy_triggered`, `log`) annotate the evaluated predicate, chosen `to` node ID (or `elseTo`), and plan version, while resume/HITL flows remain deterministic because snapshots include the full routing metadata. (`docs/architecture/flex-agents-server.md#6-component-responsibilities`, `docs/architecture/flex-agents-server.md#10-001-flex-run-streaming-contract`, `docs/architecture/flex-agents-server.md#8-hitl-and-rehydration-strategy`)
5. Automated tests cover schema validation edge cases, planner/persistence round-trips, execution outcomes for matches, misses with else branches, and predicate failures, plus guard rails preventing runtime plan mutation, per testing standards. (`docs/architecture/coding-standards.md#7-testing-expectations`)
6. Planner and runtime uphold plan topology immutability: conditional routing nodes only originate from planner output (initial plan or explicit replan), and execution code logs/blocks any attempt to add nodes outside a replan, ensuring DAG stability. (`docs/architecture/flex-agents-server.md#5-plangraph`, `docs/architecture/flex-agents-server.md#7-execution-flow`)
7. Sandbox plan graph visualization (`FlexSandboxPlanInspector.vue` and related pipelines) renders DAGs with branching/conditional routing nodes without assuming pipeline-only topology, including clear UI affordances showing each route/edge selection. (`docs/stories/8.19.flex-planner-sandbox-ui.md`, `docs/architecture/flex-agents-server.md#planner-lifecycle-events`)

## Tasks / Subtasks
- [ ] Add `ConditionalRoutingNode` schemas/types (and supporting routing edge helpers) to `@awesomeposter/shared`, ensuring logic DSL predicates compile to normalized JSON-logic before Zod validation and exports stay tree-shakable. (AC 1) (`docs/architecture/flex-agents-server.md#54-plangraph`)
- [ ] Extend `FlexPlanNodeKind`, planner compilation, and snapshot serialization to persist conditional routing metadata while keeping rehydration deterministic and guaranteeing nodes are only produced during plan compilation/replan (never via runtime injection). (AC 2, AC 6) (`docs/architecture/flex-agents-server.md#7-execution-flow`, `docs/architecture/flex-agents-server.md#9-data-model--persistence`)
- [ ] Implement conditional routing evaluation in `FlexExecutionEngine`, selecting downstream node IDs (or replan fallbacks) purely by traversing planner-emitted edges without introducing runtime nodes, and refactor the scheduler to seed from planner-defined entry nodes rather than array indexes. (AC 3, AC 7) (`docs/architecture/flex-agents-server.md#6-component-responsibilities`)
- [ ] Update telemetry emitters and persistence hooks so conditional routing decisions surface via SSE and stored run metadata without regressing resume or HITL flows. (AC 4) (`docs/architecture/flex-agents-server.md#10-001-flex-run-streaming-contract`)
- [ ] Author Vitest suites covering schema validation, planner/persistence round-trips, and execution flows for conditional routing nodes. (AC 5) (`docs/architecture/coding-standards.md#7-testing-expectations`)
- [ ] Add guard rails (validation + logging) ensuring plan topology can only change through an explicit replan request, rejecting or alerting on any runtime attempt to inject conditional nodes. (AC 6) (`docs/architecture/flex-agents-server.md#7-execution-flow`)
- [ ] Update Flex sandbox plan inspector/graph renderer (`src/components/FlexSandboxPlanInspector.vue` et al.) so branching conditional routing nodes visualize their outgoing edges, predicate states, and selections without assuming a linear pipeline. (AC 7) (`docs/stories/8.19.flex-planner-sandbox-ui.md`)

## Story Context

**Existing System Integration:**
- Integrates with: `@awesomeposter/shared` flex contracts, `packages/flex-agents-server` planner, execution engine, telemetry, persistence, and HITL resume pipeline. `[Source: architecture/source-tree.md#5-shared-libraries]` `[Source: architecture/source-tree.md#4-agents-server]`
- Technology: TypeScript, Zod, logic DSL compilation/JSON-logic evaluation, Nitro-based orchestrator services. `[Source: architecture/tech-stack.md#1-core-runtime-components]`
- Follows pattern: Planner emits PlanGraph nodes validated and executed by orchestrator services with SSE telemetry. `[Source: architecture/flex-agents-server.md#7-execution-flow]`
- Touch points: Shared schema module, planner compile step, execution engine routing, run context updates, telemetry service, persistence snapshots. `[Source: architecture/flex-agents-server.md#6-component-responsibilities]`
- Planner pipeline reminder: LLM drafts propose nodes/routes with human-readable handles and DSL predicates, then the deterministic validator/snapshot builder assigns canonical node handles, compiles predicates, and produces the executable DAG consumed by runtime components.

**Open Design Considerations:**
- Runtime policies already let callers express conditional branching; conditional routing nodes therefore need to be inserted by the planner between capability nodes so runtime execution cannot mutate topology while still preventing duplicate triggers.
- Decide how much of today’s `policies.runtime` surface migrates into planner-aware policy templates so preconditions are declared up front, with replans remaining the only mechanism to alter node ordering.
- Alignment with forthcoming agent instruction templates must avoid embedding process context inside individual agents while keeping orchestrator behaviour transparent and causally consistent.
- Flex Sandbox Plan Inspector currently assumes a linear (pipeline) plan graph; routing nodes will introduce branches, so the visualization and underlying graph data adapters must be updated in this story to keep developer tooling accurate.

## Acceptance Criteria (Detailed)

### Functional Requirements
1. Conditional routing nodes declare `kind: 'routing'`, a planner-assigned node handle (`id`) created during deterministic validation (not authored by the LLM), optional `title`/`description`, ordered `routes[]` of `{ if: PlannerDslPredicate, to: PlannerNodeHandle, metadata? }`, optional `elseTo`, and optional `metadata`, and are emitted between capability nodes during plan creation/replans to describe preconditions for downstream execution. `[Source: architecture/flex-agents-server.md#54-plangraph]`
2. Routing edges reference planner-assigned node handles already present in the validated plan graph—no inline action payloads—and include compile helpers that normalize each DSL predicate to JSON-logic while preserving a trace back to the original LLM-authored expression plus the downstream capability/system node. `[Source: architecture/flex-agents-server.md#7-execution-flow]`
3. Planner includes conditional routing nodes in PlanGraph edges without violating DAG requirements; persistence captures them for resume, and execution services refuse to add/edit nodes unless a formal replan handshake occurs. `[Source: architecture/flex-agents-server.md#9-data-model--persistence]`
4. Execution engine short-circuits on the first matching route, schedules the referenced node ID, and records the outcome before continuing along plan edges. `[Source: architecture/flex-agents-server.md#7-execution-flow]`
5. Fallback routing executes when no predicate matches: `elseTo` advances to another planner-defined node, or, if absent, the engine raises a replan request through the documented planner handshake. `[Source: architecture/flex-agents-server.md#6-component-responsibilities]`

### Integration Requirements
6. Logic DSL predicates originate in planner (LLM) drafts but are compiled/validated within `@awesomeposter/shared` to JSON-logic **during the deterministic planner phase** so execution always consumes normalized predicates linked back to their original DSL text. `[Source: architecture/flex-agents-server.md#8-hitl-and-rehydration-strategy]`
7. Execution derives its start node(s) from planner metadata (nodes with zero unmet predecessors or explicit `entry` flag) and uses a scheduler/queue keyed by planner node handles instead of walking an array index; downstream eligibility is set solely by traversing graph edges. `[Source: architecture/flex-agents-server.md#7-execution-flow]`
8. Scheduler updates occur by picking the `to` planner node handle emitted by the matching route, guaranteeing no runtime node insertion or mutation. `[Source: architecture/flex-agents-server.md#7-execution-flow]`
9. When a route targets the canonical replan/interrupt nodes, the engine triggers the existing planner handshake (`plan_requested`/`plan_updated`) using the same telemetry and persistence hooks already documented. `[Source: architecture/flex-agents-server.md#10-001-flex-run-streaming-contract]`
10. Resume/HITL flows rehydrate routing nodes because snapshots persist `routes[]`, predicate outputs, and the last-selected `to` node, ensuring deterministic playback. `[Source: architecture/flex-agents-server.md#8-hitl-and-rehydration-strategy]`
11. Telemetry/reporting surfaces explicit fields—`predicate` (original DSL text), `result` (boolean JSON-logic evaluation), `selected_to` (planner node handle or special replan token), and `plan_version`—so sandbox tooling and operators understand exactly how the DAG advanced. `[Source: architecture/flex-agents-server.md#6-component-responsibilities]`

### Quality Requirements
11. Validation errors for malformed conditions, duplicate/unknown `to` node IDs, or attempts to add nodes outside plan/replan workflows surface descriptive messages and prevent plan execution. `[Source: architecture/coding-standards.md#1-language--module-conventions]`
12. Tests cover match/miss/fallback paths, guard rails for runtime mutation attempts, and error handling when predicates throw or return non-boolean values. `[Source: architecture/coding-standards.md#7-testing-expectations]`
13. Telemetry payloads include predicate result fields, chosen node IDs, and plan version IDs whenever routing nodes fire or mutation attempts are rejected to aid sandbox debugging. `[Source: architecture/flex-agents-server.md#10-001-flex-run-streaming-contract]`

## Dev Notes
- **Previous Story Insights**: Runtime policy enforcement already relies on `PolicyNormalizer` and `FlexExecutionEngine` to route between planner nodes (including replan/hitl/emit system nodes); conditional routing nodes must reuse those pathways while remaining planner-supplied artifacts (no runtime injection) and adding explicit precondition semantics for downstream capability nodes. `[Source: architecture/flex-agents-server.md#6-component-responsibilities]`
- **Data Models**: Conditional nodes must serialize into `flex_plan_nodes` and snapshots so resume/HITL flows rehydrate predicates and metadata without expanding the plan graph at execution time. `[Source: architecture/flex-agents-server.md#9-data-model--persistence]`
- **Planner Handles**: Node IDs/handles referenced by routing edges come from the deterministic planner validator+synthesizer stage (where today’s plan nodes already get stable identifiers); LLM drafts never invent IDs directly. `[Source: architecture/flex-agents-server.md#7-execution-flow]`
- **Logic DSL Support**: Shared compiler utilities must convert DSL predicates to JSON-logic during validation/export so downstream planners/execution engines consume a consistent format. `[Source: architecture/flex-agents-server.md#6-component-responsibilities]`
- **Planner/Runtime Boundary**: Treat planner DSL as authoring-time metadata only; once compiled, execution always references the canonical JSON-logic plus planner-assigned node handles stored in snapshots/telemetry so replay/debugging never depends on raw LLM output.
- **API Specifications**: SSE `run.stream` contract needs to surface routing outcomes alongside existing planner and node events. `[Source: architecture/flex-agents-server.md#10-001-flex-run-streaming-contract]`
- **Component Specifications**: Updates target the planner compiler, execution engine, telemetry service, and persistence layer documented for flex orchestration. `[Source: architecture/flex-agents-server.md#6-component-responsibilities]`
- **Replan Controls**: When predicates fail and request replanning, engines must funnel through the existing replan handshake so any topology change occurs via planner output, not ad hoc node mutation. `[Source: architecture/flex-agents-server.md#7-execution-flow]`
- **File Locations**: Place shared contracts in `packages/shared/src/flex`, planner/execution updates in `packages/flex-agents-server/src/services`, and related tests alongside each package per workspace structure. `[Source: architecture/source-tree.md#5-shared-libraries]` `[Source: architecture/source-tree.md#4-agents-server]`
- **Testing Requirements**: Follow Vitest-based coverage expectations for new schemas, DSL-to-JSON-logic compilation, and orchestration logic. `[Source: architecture/coding-standards.md#7-testing-expectations]`
- **Technical Constraints**: Maintain strict TypeScript + Zod patterns and avoid introducing non-standard runtimes. `[Source: architecture/coding-standards.md#1-language--module-conventions]`

## Project Structure Notes
- Keep shared schema additions in `packages/shared`, orchestration logic in `packages/flex-agents-server`, and ensure any helper utilities live under existing service directories to align with the documented source tree. `[Source: architecture/source-tree.md#5-shared-libraries]` `[Source: architecture/source-tree.md#4-agents-server]`

## Testing
- `npm run test:unit -- packages/shared/__tests__/flex/conditional-routing-node.spec.ts packages/flex-agents-server/__tests__/conditional-routing-node.spec.ts packages/flex-agents-server/__tests__/flex-execution-engine.spec.ts` `[Source: architecture/coding-standards.md#7-testing-expectations]`

## Definition of Done
- [ ] Functional requirements met
- [ ] Integration requirements verified
- [ ] Existing functionality regression tested
- [ ] Code follows existing patterns and standards
- [ ] Tests pass (unit/integration as applicable)
- [ ] Documentation updated

## Risk and Compatibility Check
- **Primary Risk:** Incorrect predicate evaluation could route runs to stale nodes, trigger unnecessary replans, or tempt developers to inject ad hoc runtime nodes, leading to user-visible failures.  
  **Mitigation:** Validate logic DSL expressions (compiled to JSON-logic in shared utilities), add telemetry for outcomes, and enforce planner-only topology updates (fail fast when runtime injection is attempted). `[Source: architecture/flex-agents-server.md#7-execution-flow]`
- **Rollback:** Disable conditional routing emission in planner output and revert schema exports; existing policy triggers continue to rely on prior stories. `[Source: architecture/flex-agents-server.md#6-component-responsibilities]`

**Compatibility Verification**
- [x] No breaking changes to existing APIs
- [x] Database changes (if any) are additive only
- [x] UI changes follow existing design patterns
- [x] Performance impact is negligible

## Validation Checklist
- [ ] Story can be completed in one development session
- [x] Integration approach is straightforward
- [x] Follows existing patterns exactly
- [x] No design or architecture work required
- [x] Story requirements are unambiguous
- [x] Integration points are clearly specified
- [x] Success criteria are testable
- [x] Rollback approach is simple

## Change Log
| Date | Version | Description | Author |
|------|---------|-------------|--------|
| 2025-10-20 | 0.1 | Initial draft for conditional routing nodes in flex plan graphs. | Scrum Master |
