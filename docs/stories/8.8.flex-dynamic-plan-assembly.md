# Story 8.8: Flex Dynamic Plan Assembly

## Status
Draft

## Story
**As a** flex planner engineer,  
**I want** the planner to assemble execution graphs dynamically from live capability metadata,  
**so that** flex runs honor caller contracts with the best available agents instead of relying on a hard-coded happy path.

## Acceptance Criteria
1. Planner queries the capability registry at run start and selects candidates whose traits satisfy the TaskEnvelope’s objective, audience, and contract requirements.
2. Generated `PlanGraph` contains structuring, execution, validation, and fallback nodes derived from capability metadata (writer, strategist, qa, formatter) instead of mocked stubs, each node annotated with resolved input/output contracts before execution begins.
3. Planner injects transformation nodes automatically when the caller requests output normalization (e.g., JSON schema, channel adjustments) and annotates nodes with rationale for debugging.
4. Planner expands or adjusts the plan graph during assembly when upstream capability outputs (e.g., multiple strategic directions) or pre-execution HITL guidance require additional branches, ensuring new nodes inherit resolved contracts and provenance.
5. Capability scoring and selection logic is unit tested against at least three envelopes (LinkedIn variants, blog post, rejection scenario) to verify correct node assembly, branching, and fallback behaviour.
6. Documentation in `docs/architecture/flex-agents-server.md` is updated to describe the dynamic planning algorithm, capability scoring, branching behaviour, and node taxonomy for downstream teams.

## Tasks / Subtasks
- [ ] Extend `FlexPlanner` to hydrate capability metadata from the registry, filter by contract requirements, and score candidates (AC 1, AC 2).
- [ ] Implement node factory utilities that translate planner selections into structuring, execution, validation, and fallback nodes with context bundles (AC 2, AC 3).
- [ ] Add automatic transformation node injection for JSON schema enrichment and channel-specific formatting (AC 3).
- [ ] Support branch expansion by generating additional node sequences when planner inputs (e.g., strategist outputs, pre-execution HITL directives) request multiple variants (AC 4).
- [ ] Write unit/integration tests covering LinkedIn happy path, blog long-form scenario, and capability rejection fallback (AC 5).
- [ ] Update architecture documentation with planning flow diagrams, capability scoring description, and branching behaviour (AC 6).
- [ ] Coordinate with Story 8.9 to ensure planner signals/policies wiring points are documented for future work (AC 6).

## Story Context

**Existing System Integration:**
- Integrates with: Capability registry (Story 8.2 — exposes live capability metadata and scoring inputs), `/api/v1/flex/run.stream` endpoint (Story 8.3 — streams assembled plan graphs and SSE events), shared contracts (Story 8.1 — defines `TaskEnvelope`, contract, and policy schemas), future telemetry additions (Story 8.6 — consumes node annotations and selection logs).
- Technology: TypeScript, Nitro (H3), planner services within `packages/flex-agents-server`, existing registry repositories.
- Follows pattern: Legacy orchestrator dynamic task selection, extended for flex metadata-driven planning.
- Touch points: `flex-planner.ts`, `flex-run-coordinator.ts`, shared Zod schemas, SPA telemetry/debug tooling.

**References:**
- `docs/architecture/flex-agents-server.md#56-agentcapability` — Canonical capability metadata shape used when filtering and scoring registry entries.
- `docs/architecture/flex-agents-server.md#54-plangraph` — Plan graph structure, node taxonomy, and annotation requirements the planner must emit.
- `docs/architecture/flex-agents-server.md#7-execution-flow` — End-to-end orchestration sequence showing planner hand-offs to runtime executors.
- `docs/architecture/flex-agents-server.md#11-capability-registry--agent-contracts` — Registry lookup semantics and contract enforcement the planner relies on.
- `docs/stories/8.3.flex-planner-endpoint.md` — Existing planner endpoint behaviours and SSE payload expectations the dynamic assembly must extend.
- `docs/stories/8.2.flex-server-scaffold.md` — Capability registry bootstrap details and API surface that back the planner’s metadata hydration.
## Acceptance Criteria (Detailed)

### Functional Requirements
1. Planner loads live capability metadata at runtime (no static imports) and caches selections per run.
2. Capability scoring accounts for language, channel, content type, cost envelope, and declared strengths.
3. Planner emits annotated `PlanGraph` nodes describing why each capability, transformation, and branch was chosen, including provenance for dynamically added paths.
4. Branch expansion handles multi-output scenarios (e.g., strategist returning three directions) by spawning sibling writer/validator nodes with inherited policies and contracts.
5. Fallback nodes trigger when no capability meets minimum score threshold, with clear error events for HITL intervention.

### Integration Requirements
5. Node generation honours shared `TaskEnvelope` contract fields, including `policies`, `outputContract`, and `context`.
6. Planner exposes hooks for policy overrides (to be completed in Story 8.9) without requiring refactors.
7. SSE stream from Story 8.3 reflects the dynamic node taxonomy (new `plan_branch`, `plan_fallback` events) without breaking envelope shape.
8. Pre-execution HITL adjustments (operator edits before execution) can trigger branch changes that propagate to persistence and telemetry.

### Quality Requirements
8. Unit tests validate scoring filters and fallback triggers; integration tests assert assembled plan graphs match expected snapshots.
9. Logging includes capability IDs and selection scores for observability alignment (Story 8.6 dependency).
10. Documentation covers planner flow, scoring weights, and extension points.

## Technical Notes
- **Integration Approach:** Introduce `CapabilitySelector` service to run filters and scoring over registry data; planner composes structuring/execution nodes using selector output.
- **Existing Pattern Reference:** Legacy orchestrator’s dynamic task queue (if available) and shared planner utilities already used in Story 8.3.
- **Key Constraints:** Must remain feature-flagged until Story 8.9 completes policy handling; ensure planner gracefully degrades when registry is empty (emit HITL escalation).

## Definition of Done
- [ ] Functional requirements met
- [ ] Integration requirements verified
- [ ] Existing functionality regression tested (legacy flows unaffected, flex happy path still works)
- [ ] Code follows existing patterns and standards
- [ ] Tests pass (unit/integration)
- [ ] Documentation updated (planner algorithm section)

## Risk and Compatibility Check
- **Primary Risk:** Incorrect scoring leading to mismatched capability assignments.
- **Mitigation:** Add deterministic tests and logging; review scoring weights with domain experts.
- **Rollback:** Feature flag the dynamic selector and revert to the stubbed plan from Story 8.3.

**Compatibility Verification**
- [x] No breaking changes to existing APIs
- [x] Database changes (if any) are additive only
- [x] UI changes follow existing design patterns
- [x] Performance impact is negligible

## Validation Checklist
- [ ] Story can be completed in one development session
- [x] Integration approach is straightforward
- [x] Follows existing patterns exactly
- [x] No design or architecture work required
- [ ] Story requirements are unambiguous
- [x] Integration points are clearly specified
- [x] Success criteria are testable
- [x] Rollback approach is simple

## Success Criteria
1. Planner assembles plan graphs dynamically from registry data for multiple envelope types.
2. Operators can trace node annotations to understand capability selection decisions.
3. Flex flows demonstrate runtime adaptability beyond the original happy-path demo.

## Important Notes
- Coordinate scoring weights with content strategy stakeholders to ensure planner favours correct agents.
- After implementation, revisit story sequencing to ensure telemetry (8.6) and policy (8.9) stories consume the new hooks without rework.
