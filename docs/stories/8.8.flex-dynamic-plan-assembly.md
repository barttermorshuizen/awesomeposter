# Story 8.8: Flex Dynamic Plan Assembly

## Status
Done

## Story
**As a** flex planner engineer,  
**I want** the planner to assemble execution graphs dynamically from live capability metadata,  
**so that** flex runs honor caller contracts with the best available agents instead of relying on a hard-coded happy path.

## Acceptance Criteria
1. Planner hydrates live capability metadata and facet definitions from the shared catalog, selecting candidates whose facet coverage satisfies the TaskEnvelope objective, policies, and contract requirements. (`docs/architecture/flex-agents-server.md:57`)
2. Generated `PlanGraph` contains structuring, execution, validation, and fallback nodes annotated with selected facet arrays, compiled `inputSchema`/`outputSchema`, capability provenance, and plan version info before execution begins. (`docs/architecture/flex-agents-server.md:138`)
3. Planner injects transformation nodes automatically when caller policies/output contracts require normalization (e.g., JSON schema, channel adjustments), recording facet rationale and derived capability flags. (`docs/architecture/flex-agents-server.md:138`)
4. Planner expands or adjusts the plan graph during assembly when upstream outputs or pre-execution HITL directives request additional branches, ensuring new nodes inherit facet arrays, compiled schemas, and provenance. (`docs/architecture/flex-agents-server.md:150`)
5. Planner emits plan versions compatible with hybrid replanning: nodes carry rationale, facet provenance, and linkage for policy triggers/resume flows. (`docs/architecture/flex-agents-server.md:168`)
6. Capability scoring and selection logic is unit tested against at least three envelopes (LinkedIn variants, blog post, rejection scenario) to verify correct node assembly, branching, fallback behaviour, and derived capability handling. (`docs/architecture/flex-agents-server.md:88`)
7. Documentation in `docs/architecture/flex-agents-server.md` is updated to include facet-driven planning algorithm, capability scoring, branching behaviour, and node taxonomy examples. (`docs/architecture/flex-agents-server.md:169`)

## Tasks / Subtasks
- [ ] Extend `FlexPlanner` to hydrate capability metadata and facet catalog entries, filtering candidates by facet coverage and policy contracts (AC 1).
- [ ] Implement node factory utilities that attach selected facet arrays, compiled schemas from `FacetContractCompiler`, provenance, and plan version metadata (AC 2).
- [ ] Add automatic transformation/normalization node injection based on caller policies/output contracts, flagging derived capabilities where relevant (AC 3).
- [ ] Support branch expansion by generating additional node sequences when planner inputs (e.g., strategist outputs, pre-execution HITL directives) request variants, copying facets/schemas/provenance (AC 4).
- [ ] Emit plan versions compatible with hybrid replanning, including rationale and policy trigger hooks for Story 8.9 (AC 5).
- [ ] Write unit/integration tests covering LinkedIn happy path, blog scenario, rejection fallback, and derived capability detection, asserting facet arrays + compiled schemas (AC 6).
- [ ] Update architecture documentation with facet-driven planning flow diagrams, scoring description, and branching behaviour (AC 7).
- [ ] Coordinate with Story 8.9 to ensure planner signal/policy wiring points and plan version metadata are documented for future work (AC 5, AC 7).

## Story Context

**Existing System Integration:**
- Integrates with: Capability registry (Story 8.2), facet catalog/contract compiler (Story 8.12), hybrid planner handshake (Story 8.14), policy engine hooks (Story 8.9), `/api/v1/flex/run.stream` endpoint (Story 8.3), shared contracts (Story 8.1), telemetry instrumentation (Story 8.6).
- Technology: TypeScript, Nitro (H3), planner services within `packages/flex-agents-server`, shared facet/contract utilities.
- Follows pattern: Legacy orchestrator dynamic task selection enriched with facet-driven metadata and planner lifecycle events.
- Touch points: `flex-planner.ts`, `flex-run-coordinator.ts`, `FacetContractCompiler`, `CapabilityRegistry`, telemetry/debug tooling.

**References:**
- `docs/architecture/flex-agents-server.md#56-agentcapability` — Canonical capability metadata shape used when filtering and scoring registry entries.
- `docs/architecture/flex-agents-server.md#54-plangraph` — Plan graph structure, node taxonomy, and annotation requirements the planner must emit.
- `docs/architecture/flex-agents-server.md#7-execution-flow` — End-to-end orchestration sequence showing planner hand-offs to runtime executors.
- `docs/architecture/flex-agents-server.md#11-capability-registry--agent-contracts` — Registry lookup semantics and contract enforcement the planner relies on.
- `docs/stories/8.3.flex-planner-endpoint.md` — Existing planner endpoint behaviours and SSE payload expectations the dynamic assembly must extend.
- `docs/stories/8.2.flex-server-scaffold.md` — Capability registry bootstrap details and API surface that back the planner’s metadata hydration.
## Acceptance Criteria (Detailed)

### Functional Requirements
1. Planner loads live capability metadata and facet definitions at runtime (no static imports) and caches selections per run.
2. Capability scoring accounts for language, channel, content type, cost envelope, strengths, and facet alignment.
3. Planner emits annotated `PlanGraph` nodes describing why each capability, transformation, and branch was chosen, including facet provenance, compiled schemas, and derived capability markers.
4. Branch expansion handles multi-output scenarios (e.g., strategist returning three directions) by spawning sibling writer/validator nodes with inherited policies, facets, and compiled schemas.
5. Fallback nodes trigger when no capability meets minimum score threshold, emitting clear events for HITL intervention with facet context.

### Integration Requirements
5. Node generation honours shared `TaskEnvelope` contract fields, including `policies`, `outputContract`, facet selections, and compiled schemas.
6. Planner exposes hooks for policy overrides/replanning (Story 8.9) and records plan versions without requiring refactors.
7. SSE stream from Story 8.3 reflects the dynamic node taxonomy (including `plan_branch`, `plan_fallback`, planner lifecycle events) without breaking envelope shape.
8. Pre-execution HITL adjustments (operator edits before execution) can trigger branch changes that propagate to plan versions, persistence, and telemetry.

### Quality Requirements
8. Unit tests validate facet selection/scoring filters and fallback triggers; integration tests assert assembled plan graphs (facet arrays + compiled schemas) match expected snapshots.
9. Logging includes capability IDs, selected facets, selection scores, and plan version IDs for observability alignment (Story 8.6 dependency).
10. Documentation covers facet-driven planner flow, scoring weights, and extension points.

## Technical Notes
- **Integration Approach:** Use `CapabilitySelector` with facet catalog + contract compiler to filter candidates and generate annotated nodes.
- **Existing Pattern Reference:** Legacy orchestrator dynamic task queue plus new facet-driven planning/sequence diagram (sections 5.6–5.8).
- **Key Constraints:** Must remain feature-flagged until Story 8.9 completes policy handling; ensure planner gracefully degrades when registry or facet coverage is empty (emit HITL escalation and diagnostics).

## Definition of Done
- [ ] Functional requirements met
- [ ] Integration requirements verified
- [ ] Existing functionality regression tested (legacy flows unaffected, flex happy path still works)
- [ ] Code follows existing patterns and standards
- [ ] Tests pass (unit/integration)
- [ ] Documentation updated (planner algorithm section)

## Risk and Compatibility Check
- **Primary Risk:** Incorrect scoring leading to mismatched capability assignments.
- **Mitigation:** Add deterministic tests and logging; review scoring weights with domain experts.
- **Rollback:** Feature flag the dynamic selector and revert to the stubbed plan from Story 8.3.

**Compatibility Verification**
- [x] No breaking changes to existing APIs
- [x] Database changes (if any) are additive only
- [x] UI changes follow existing design patterns
- [x] Performance impact is negligible

## Validation Checklist
- [ ] Story can be completed in one development session
- [x] Integration approach is straightforward
- [x] Follows existing patterns exactly
- [x] No design or architecture work required
- [x] Story requirements are unambiguous
- [x] Integration points are clearly specified
- [x] Success criteria are testable
- [x] Rollback approach is simple

## Success Criteria
1. Planner assembles plan graphs dynamically from registry data for multiple envelope types.
2. Operators can trace node annotations to understand capability selection decisions.
3. Flex flows demonstrate runtime adaptability beyond the original happy-path demo.

## Important Notes
- Coordinate scoring weights with content strategy stakeholders to ensure planner favours correct agents.
- After implementation, revisit story sequencing to ensure telemetry (8.6) and policy (8.9) stories consume the new hooks without rework.

## QA Results

### Gate Status

Gate: PASS → docs/qa/gates/8.8-flex-dynamic-plan-assembly.yml
