# Story 8.9: Flex Planner Signals & Policy Overrides

## Status
Draft

## Story
**As a** marketing operations lead,  
**I want** the flex planner to enforce runtime policies and react to execution signals,  
**so that** flex runs can adapt mid-flight (rewrites, fallbacks, escalations) when quality, latency, or compliance thresholds are breached.

## Acceptance Criteria
1. Planner consumes `TaskEnvelope.policies` (quality thresholds, cost caps, retry limits, channel rules) and exposes them to execution components via a normalized policy map.
2. Execution engine monitors runtime signals (quality scores, validation results, HITL feedback, latency) and triggers plan mutations—such as inserting rewrite nodes or selecting alternate capabilities—when policies are violated.
3. Replanning updates the active `PlanGraph` immutably (new version persisted) and emits `plan_updated` / `policy_triggered` SSE events so the UI and resume flows reflect the changed execution path.
4. Policy enforcement is covered by automated tests simulating at least four scenarios: quality < threshold (rewrite), cost cap exceeded (fallback), latency breach (capability swap), and manual HITL escalation acceptance.
5. Documentation in `docs/architecture/flex-agents-server.md` details supported policies, signal sources, event semantics, and guidance for authoring TaskEnvelope policies.

## Tasks / Subtasks
- [ ] Create `PolicyEngine` module to normalize TaskEnvelope policies, provide evaluation helpers, and expose decision hooks to planner/execution components (AC 1, AC 2).
- [ ] Extend execution engine to emit runtime signals (quality scores, duration, retries) and invoke `PolicyEngine` for decision making (AC 2).
- [ ] Implement plan mutation workflow: clone existing plan, apply inserted/removed nodes, persist new version, and emit SSE events (`plan_updated`, `policy_triggered`, `rewrite_requested`) (AC 2, AC 3).
- [ ] Update persistence layer to version `flex_plan_nodes` / snapshots so resume/debug endpoints can load the latest plan graph (AC 3).
- [ ] Add automated tests covering quality rewrite, cost fallback, latency swap, and HITL escalation policies (AC 4).
- [ ] Document policy configuration, signal sources, and SSE updates in architecture/spec docs; include examples for policy authors (AC 5).
- [ ] Coordinate with telemetry story (8.6) to ensure policy-trigger logs/metrics are captured (AC 5).

## Story Context

**Existing System Integration:**
- Integrates with: Dynamic plan assembly (Story 8.8), flex execution engine (Story 8.3), persistence updates (Story 8.4), resume/debug tooling (Story 8.5), telemetry instrumentation (Story 8.6).
- Technology: TypeScript, Nitro SSE, Ajv validators, capability registry.
- Follows pattern: Legacy orchestrator policy hooks (if any) and HITL feedback loops.
- Touch points: `flex-planner.ts`, `flex-execution-engine.ts`, `flex-run-coordinator.ts`, SSE service, persistence repositories.

## Acceptance Criteria (Detailed)

### Functional Requirements
1. Policies support thresholds for quality, latency, budget, rewrite count, and automatic escalation rules.
2. Execution engine produces normalized signal payloads (`SignalEnvelope`) after each node completes or fails.
3. Policy violations result in deterministic plan mutations (rewrite node insertion, fallback capability selection, HITL escalation), with rationale recorded on nodes.
4. Policy evaluation respects per-node overrides (e.g., certain steps may opt out of quality rewrite).

### Integration Requirements
5. Plan versioning integrates with persistence so `flex_plan_snapshot` stores policy-triggered changes.
6. SSE event stream includes new event types (`policy_triggered`, `plan_updated`, `rewrite_started`) while maintaining envelope signature.
7. Resume endpoint (Story 8.5) can resume from the latest plan version without manual intervention.

### Quality Requirements
8. Tests verify policy evaluation order (e.g., cost cap before rewrites) and ensure infinite replanning loops are prevented via guard rails.
9. Logging captures policy decisions with run ID, node ID, and policy details for auditability.
10. Documentation outlines policy authoring guidelines, signal schema, and debugging steps.

## Technical Notes
- **Integration Approach:** Introduce a `PolicyContext` shared between planner and execution engine; use immutable plan diffs to support versioning.
- **Existing Pattern Reference:** Legacy system’s HITL escalation logic and retry policies; adapt to flex planner architecture.
- **Key Constraints:** Maintain feature-flag gating until telemetry (8.6) and persistence (8.4) stories land; ensure replanning decisions are deterministic to avoid flapping.

## Definition of Done
- [ ] Functional requirements met
- [ ] Integration requirements verified
- [ ] Existing functionality regression tested (legacy flows unaffected)
- [ ] Code follows existing patterns and standards
- [ ] Tests pass (unit/integration)
- [ ] Documentation updated (policy engine section)

## Risk and Compatibility Check
- **Primary Risk:** Policy loops or over-aggressive replanning causing instability.
- **Mitigation:** Add guard rails (max rewrites, cooldowns) and comprehensive tests.
- **Rollback:** Disable policy engine via feature flag and revert to static plan from Story 8.8.

**Compatibility Verification**
- [x] No breaking changes to existing APIs
- [x] Database changes (if any) are additive only
- [x] UI changes follow existing design patterns
- [x] Performance impact is negligible

## Validation Checklist
- [ ] Story can be completed in one development session
- [x] Integration approach is straightforward
- [x] Follows existing patterns exactly
- [x] No design or architecture work required
- [x] Story requirements are unambiguous
- [x] Integration points are clearly specified
- [x] Success criteria are testable
- [x] Rollback approach is simple

## Success Criteria
1. Flex runs adapt to runtime conditions (quality, latency, cost) without manual intervention.
2. Operators see clear UI/log signals when policies trigger replanning or escalations.
3. Planner/execution remain deterministic and debuggable despite plan mutations.

## Important Notes
- Align signal schema with upcoming telemetry instrumentation (Story 8.6).
- Consider future UI enhancements to surface policy rationales in operator dashboards once baseline telemetry is in place.
