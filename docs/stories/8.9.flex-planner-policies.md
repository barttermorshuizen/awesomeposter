# Story 8.9: Flex Task Policy Schema Foundation

## Status
Draft

## Story
**As a** flex orchestrator maintainer,  
**I want** TaskEnvelope policies to be represented with a single canonical schema shared by planner and runtime components,  
**so that** downstream stories can build consistent policy enforcement, action dispatch, and documentation on a stable foundation.

**Blocks:** Stories 8.23 (action execution), 8.25 (envelope-driven planner). Flag Story 8.24 to reuse the unified action taxonomy.

## Acceptance Criteria
1. `@awesomeposter/shared/flex` exports `TaskPolicies`, `PlannerPolicy`, `RuntimePolicy`, `PolicyTrigger`, `NodeSelector`, and `Action` exactly as described in `docs/architecture/flex-agents-server.md` (Section 5.3), with schema validation helpers and exhaustive type tests. (`docs/architecture/flex-agents-server.md#5.3-taskpolicies`)
2. `PolicyNormalizer` accepts caller payloads, validates them against the canonical schema, applies defaults (enablement, empty arrays), and emits normalized policies that planner/runtime components can consume without additional coercion. (`packages/flex-agents-server/src/services/policy-normalizer.ts`)
3. `PlannerService` reads planner policies from the normalized structure (topology, selection, optimisation, directives) and surfaces them in planner prompts and plan metadata; existing implicit policy fields are removed or mapped to the new schema. (`packages/flex-agents-server/src/services/flex-planner.ts`)
4. Execution and telemetry layers accept the unified `RuntimePolicy` shape and continue to default to `replan` actions; add adapters or TODOs where the current action names (`hitl_pause`, `fail_run`, etc.) differ so Stories 8.23/8.24 can finish alignment without breaking behavior. (`packages/flex-agents-server/src/runtime/**`)
5. Architecture documentation in `docs/architecture/flex-agents-server.md` is updated with the canonical schema (TaskPolicies, PlannerPolicy, RuntimePolicy, Action), example payload, and naming alignment guidance. (`docs/architecture/flex-agents-server.md#5.3-taskpolicies`)
6. Automated tests cover planner policy normalization, runtime policy parsing, and serialization routines (at least one test per trigger/action kind) to guarantee backwards compatibility with existing envelopes. (`packages/flex-agents-server/__tests__/policies/**/*.spec.ts`)

## Tasks / Subtasks
- [ ] Promote `docs/notes/policies.md` definitions into `@awesomeposter/shared/flex` and regenerate type exports (AC 1).
- [ ] Update `PolicyNormalizer` to emit canonical `TaskPolicies` with validation errors surfaced to callers (AC 2).
- [ ] Wire planner services to consume `PlannerPolicy` topology/selection/optimisation hints and remove legacy ad-hoc policy fields (AC 3).
- [ ] Introduce runtime policy adapters so current dispatcher logic reads the canonical `RuntimePolicy` + `Action`, adding TODO references for Stories 8.23/8.24 where further alignment is required (AC 4).
- [ ] Refresh architecture documentation with the canonical schema, example envelope, and action naming guidance (AC 5).
- [ ] Add unit and integration tests covering policy normalization, serialization, and backwards compatibility (AC 6).

## Story Context

**Existing System Integration:**
- Integrates with: Dynamic plan assembly (Story 8.8), facet catalog/contract compiler (Story 8.12), hybrid planner loop (Story 8.14), execution engine (Story 8.3), persistence updates (Story 8.4), resume/debug tooling (Story 8.5), telemetry instrumentation (Story 8.6).
- Technology: TypeScript, Nitro SSE, policy evaluation utilities, capability registry.
- Follows pattern: Legacy orchestrator policy hooks and HITL feedback loops enhanced with planner handshake.
- Touch points: `flex-planner.ts`, `flex-execution-engine.ts`, `flex-run-coordinator.ts`, `PolicyEngine`, SSE/Telemetry services, persistence repositories.

## Acceptance Criteria (Detailed)

### Functional Requirements
1. `TaskEnvelope` payloads that included legacy policy objects continue to parse, with differences surfaced as validation errors or TODOs in dispatcher code.
2. Planner prompt composition uses the canonical policy structure when providing topology/selection/optimisation hints.
3. Runtime policy evaluation reads the canonical `RuntimePolicy` shape and records the selected `Action` in telemetry.
4. A shared `Action` type is exported and used everywhere policies request runtime behavior; current dispatcher names that differ are annotated for follow-up.

### Integration Requirements
5. Planner, execution engine, and telemetry services all import `TaskPolicies` from the shared package rather than duplicating types.
6. Resume/rehydration flows persist normalized policy metadata so policy-aware tooling remains consistent.
7. Documentation links to the canonical schema locations for planner prompts and runtime dispatcher guidance.

### Quality Requirements
8. Unit tests cover planner policy normalization, runtime trigger parsing, and serialization edge cases.
9. Logging captures policy IDs and selected action types using the canonical names.
10. Documentation outlines authoring guidelines and explicitly calls out where action naming alignment is pending follow-up work.

## Technical Notes
- **Integration Approach:** Promote the canonical schema into the shared package, update normalization logic, and thread the resulting structures into planner prompts and runtime dispatch while leaving follow-up action handling to Stories 8.23/8.24.
- **Existing Pattern Reference:** `docs/architecture/flex-agents-server.md#5.3-taskpolicies`, legacy HITL escalation hooks, and the hybrid planner loop (Section 5.8).
- **Key Constraints:** Maintain backwards compatibility with existing envelopes; clearly annotate any action-name mismatches that need resolution in Story 8.23.

## Definition of Done
- [ ] Functional requirements met
- [ ] Integration requirements verified
- [ ] Existing functionality regression tested (legacy flows unaffected)
- [ ] Code follows existing patterns and standards
- [ ] Tests pass (unit/integration)
- [ ] Documentation updated (policy engine section)

## Risk and Compatibility Check
- **Primary Risk:** Misaligned action names causing dispatcher regressions.
- **Mitigation:** Keep adapters/TODOs where names diverge and add regression tests.
- **Rollback:** Revert to legacy policy schema in shared package and restore old normalizer behavior (feature-flag guarded).

**Compatibility Verification**
- [x] No breaking changes to existing APIs
- [x] Database changes (if any) are additive only
- [x] UI changes follow existing design patterns
- [x] Performance impact is negligible

## Validation Checklist
- [ ] Story can be completed in one development session
- [x] Integration approach is straightforward
- [x] Follows existing patterns exactly
- [x] No design or architecture work required
- [x] Story requirements are unambiguous
- [x] Integration points are clearly specified
- [x] Success criteria are testable
- [x] Rollback approach is simple

## Success Criteria
1. Planner and runtime components import the same TaskPolicies types with no duplicated schema definitions.
2. Policy normalization errors surface deterministically during envelope submission.
3. Future stories (8.23, 8.24, 8.25) can build on the unified schema without additional refactors.

## Important Notes
- Align policy schema updates with telemetry instrumentation (Story 8.6) once canonical action names are in place.
- Keep a TODO list of dispatcher action-name mismatches for Stories 8.23 and 8.24.
- Ensure schema migrations remain additive so envelopes authored before this story continue to validate.
