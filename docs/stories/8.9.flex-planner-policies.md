# Story 8.9: Flex Planner Signals & Policy Overrides

## Status
Draft

## Story
**As a** marketing operations lead,  
**I want** the flex planner to enforce runtime policies and react to execution signals,  
**so that** flex runs can adapt mid-flight (rewrites, fallbacks, escalations) when quality, latency, or compliance thresholds are breached.

## Acceptance Criteria
1. Policy engine normalizes `TaskEnvelope.policies` (quality thresholds, cost caps, retry limits, channel rules) into a shared policy map enriched with facet/capability context for planner and execution components. (`docs/architecture/flex-agents-server.md:168`)
2. Execution engine monitors runtime signals (quality scores, validation, HITL feedback, latency) and, on violations, requests planner deltas through the hybrid handshake instead of mutating plans locally. (`docs/architecture/flex-agents-server.md:205`)
3. Replanning persists new plan versions (facet arrays, compiled schemas, rationale) and emits SSE events (`policy_triggered`, `plan_updated`, `plan_rejected` when applicable) so UI/resume flows reflect changes. (`docs/architecture/flex-agents-server.md:210`)
4. Logging/telemetry capture policy decisions with run ID, plan version, node ID, policy metadata, and emitted events align with Story 8.6 instrumentation. (`docs/architecture/flex-agents-server.md:220`)
5. Policy enforcement is covered by automated tests simulating at least four scenarios: quality rewrite, cost fallback, latency swap, and manual HITL escalation acceptance, asserting planner interaction and persisted plan versions. (`docs/architecture/flex-agents-server.md:205`)
6. Documentation in `docs/architecture/flex-agents-server.md` details supported policies, signal sources, plan versioning, and authoring guidance. (`docs/architecture/flex-agents-server.md:210`)

## Tasks / Subtasks
- [ ] Create `PolicyEngine` module to normalize `TaskEnvelope` policies with facet/capability context and expose evaluation hooks for planner/execution components (AC 1).
- [ ] Extend execution engine to emit normalized signals and request planner deltas via `PlannerService` handshake when policies trigger (AC 2).
- [ ] Implement replanning workflow that pauses execution, requests planner deltas, persists new plan versions, and emits SSE events (`policy_triggered`, `plan_updated`, `plan_rejected`) (AC 2, AC 3).
- [ ] Update persistence layer to version `flex_plan_nodes` / snapshots with policy rationale, plan version IDs, and facet provenance (AC 3).
- [ ] Add automated tests covering quality rewrite, cost fallback, latency swap, and HITL escalation, verifying planner interaction, plan versioning, and telemetry/log outputs (AC 5).
- [ ] Document policy configuration, signal sources, SSE/telemetry updates, and authoring guidance in architecture/spec docs (AC 6).
- [ ] Coordinate with telemetry story (8.6) to ensure policy-trigger metrics/logs (including plan version + facets) are captured (AC 4).

## Story Context

**Existing System Integration:**
- Integrates with: Dynamic plan assembly (Story 8.8), facet catalog/contract compiler (Story 8.12), hybrid planner loop (Story 8.14), execution engine (Story 8.3), persistence updates (Story 8.4), resume/debug tooling (Story 8.5), telemetry instrumentation (Story 8.6).
- Technology: TypeScript, Nitro SSE, policy evaluation utilities, capability registry.
- Follows pattern: Legacy orchestrator policy hooks and HITL feedback loops enhanced with planner handshake.
- Touch points: `flex-planner.ts`, `flex-execution-engine.ts`, `flex-run-coordinator.ts`, `PolicyEngine`, SSE/Telemetry services, persistence repositories.

## Acceptance Criteria (Detailed)

### Functional Requirements
1. Policies support thresholds for quality, latency, budget, rewrite count, automatic escalation rules, and can reference facets/capability tags.
2. Execution engine produces normalized signal payloads (`SignalEnvelope`) after each node completes/fails and routes violations through the planner handshake.
3. Policy violations result in deterministic planner deltas (rewrite node insertion, fallback capability selection, HITL escalation) with rationale, facet provenance, and plan version updates recorded on nodes.
4. Policy evaluation respects per-node overrides (e.g., certain steps may opt out of quality rewrite) and logs rationale for auditability.

### Integration Requirements
5. Plan versioning integrates with persistence so `flex_plan_snapshot` stores policy-triggered changes, facet provenance, and rationale.
6. SSE event stream includes planner lifecycle and policy events (`plan_requested`, `plan_rejected`, `policy_triggered`, `plan_updated`, `rewrite_started`) while maintaining envelope signature.
7. Resume endpoint (Story 8.5) can resume from the latest plan version without manual intervention and reports the triggering policy.

### Quality Requirements
8. Tests verify policy evaluation order (e.g., cost cap before rewrites) and ensure guard rails prevent infinite replanning loops.
9. Logging captures policy decisions with run ID, plan version, node ID, facet set, and policy details for auditability.
10. Documentation outlines policy authoring guidelines, signal schema, planner handshake, and debugging steps.

## Technical Notes
- **Integration Approach:** Introduce a `PolicyContext` shared between planner and execution engine; evaluate signals via `PolicyEngine` and request planner deltas through the hybrid handshake; persist immutable plan diffs.
- **Existing Pattern Reference:** Legacy HITL escalation logic, retry policies, and new hybrid planner sequence (sections 5.8, 11) in the architecture spec.
- **Key Constraints:** Keep feature-flag gating until telemetry (8.6) and persistence (8.4) updates land; ensure guard rails prevent oscillating replans.

## Definition of Done
- [ ] Functional requirements met
- [ ] Integration requirements verified
- [ ] Existing functionality regression tested (legacy flows unaffected)
- [ ] Code follows existing patterns and standards
- [ ] Tests pass (unit/integration)
- [ ] Documentation updated (policy engine section)

## Risk and Compatibility Check
- **Primary Risk:** Policy loops or over-aggressive replanning causing instability.
- **Mitigation:** Add guard rails (max rewrites, cooldowns) and comprehensive tests.
- **Rollback:** Disable policy engine via feature flag and revert to static plan from Story 8.8.

**Compatibility Verification**
- [x] No breaking changes to existing APIs
- [x] Database changes (if any) are additive only
- [x] UI changes follow existing design patterns
- [x] Performance impact is negligible

## Validation Checklist
- [ ] Story can be completed in one development session
- [x] Integration approach is straightforward
- [x] Follows existing patterns exactly
- [x] No design or architecture work required
- [x] Story requirements are unambiguous
- [x] Integration points are clearly specified
- [x] Success criteria are testable
- [x] Rollback approach is simple

## Success Criteria
1. Flex runs adapt to runtime conditions (quality, latency, cost) without manual intervention.
2. Operators see clear UI/log signals when policies trigger replanning or escalations.
3. Planner/execution remain deterministic and debuggable despite plan mutations.

## Important Notes
- Align signal schema with upcoming telemetry instrumentation (Story 8.6).
- Consider future UI enhancements to surface policy rationales in operator dashboards once baseline telemetry is in place.
- Ensure policy guard rails log plan version/trigger metadata for debugging and audit readiness.
